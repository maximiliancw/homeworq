{% extends "_layout.html" %}
{% block title %}Dashboard{% endblock %}

{% block content %}
<section x-data="dashboard()" x-init="init()" class="container">
    <!-- Summary Metrics -->
    <div class="grid">
        <article>
            <h3>Tasks</h3>
            <span x-text="$store.data.metrics.totalTasks || '-'"></span>
        </article>
        <article>
            <h3>Jobs</h3>
            <span x-text="$store.data.metrics.activeJobs || '-'"></span>
        </article>
        <article>
            <h3>Results</h3>
            <span x-text="$store.data.metrics.totalExecutions || '-'"></span>
        </article>
        <article>
            <h3>System</h3>
            <kbd x-bind:class="$store.data.health.healthy ? 'pico-background-green-500' : 'pico-background-red-500'"
                x-text="$store.data.health.healthy ? 'healthy' : 'unstable'">
                unknown
            </kbd>
        </article>
    </div>

    <!-- Recent Activity & Next Executions -->
    <div class="grid">
        <article>
            <header>
                <h3>Recent Jobs</h3>
            </header>
            <template x-if="$store.data.analytics.recentActivity.length === 0">
                <p class="text-muted">No recent activity</p>
            </template>
            <template x-if="$store.data.analytics.recentActivity.length > 0">
                <table>
                    <thead>
                        <tr>
                            <th scope="col">Job</th>
                            <th scope="col">When</th>
                            <th scope="col">Duration</th>
                            <th scope="col">Status</th>
                        </tr>
                    </thead>
                    <tbody style="font-size: .75rem">
                        <template x-for="exec in $store.data.analytics.recentActivity" :key="exec.id">
                            <tr>
                                <td>
                                    <a x-bind:href="`/results/${exec.job.id}`" x-text="exec.job.name"></a>
                                </td>
                                <td x-text="formatTimeAgo(exec.started_at)"></td>
                                <td x-show="exec.duration !== null" x-text="formatDuration(exec.duration)"></td>
                                <td x-text="getStatusEmoji(exec.status)"></td>
                            </tr>
                        </template>
                    </tbody>
                </table>
            </template>
        </article>
        <article>
            <header>
                <h3>Upcoming Jobs</h3>
            </header>
            <template x-if="$store.data.analytics.upcomingExecutions.length === 0">
                <p class="text-muted">No upcoming executions</p>
            </template>
            <template x-if="$store.data.analytics.upcomingExecutions.length > 0">
                <table>
                    <thead>
                        <tr>
                            <th scope="col">Job</th>
                            <th scope="col">Next Run</th>
                        </tr>
                    </thead>
                    <tbody>
                        <template x-for="job in $store.data.analytics.upcomingExecutions" :key="job.id">
                            <tr>
                                <td><strong x-text="job.name"></strong></td>
                                <td x-text="formatDate(job.next_run)"></td>
                            </tr>
                        </template>
                    </tbody>
                </table>
            </template>
        </article>
    </div>

    <!-- Charts -->
    <div class="grid">
        <article>
            <header>
                <h3>Execution History</h3>
            </header>
            <div class="chart-container">
                <canvas id="executionHistoryChart"></canvas>
                <template x-if="!hasExecutionData">
                    <p class="text-muted text-center">No execution data available</p>
                </template>
            </div>
        </article>
        <article>
            <header>
                <h3>Task Distribution</h3>
            </header>
            <div class="chart-container">
                <canvas id="taskDistributionChart"></canvas>
                <template x-if="!hasDistributionData">
                    <p class="text-muted text-center">No distribution data available</p>
                </template>
            </div>
        </article>
    </div>
</section>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    function dashboard() {
        return {
            executionHistory: null,
            taskDistribution: null,
            hasExecutionData: false,
            hasDistributionData: false,
            lastUpdateTime: null,

            async init() {
                // Initial data fetch
                await Alpine.store('data').fetchAll();

                // Delay chart initialization to ensure DOM and data are ready
                setTimeout(() => {
                    this.initCharts();
                }, 100);

                // Set up interval for updates with cleanup
                const intervalId = setInterval(async () => {
                    await Alpine.store('data').fetchAll();
                    if (this.executionHistory && this.taskDistribution) {
                        this.updateCharts();
                    }
                }, 60000);

                // Cleanup on component destroy
                this.$cleanup = () => {
                    clearInterval(intervalId);
                    if (this.executionHistory) {
                        this.executionHistory.destroy();
                    }
                    if (this.taskDistribution) {
                        this.taskDistribution.destroy();
                    }
                };
            },

            initCharts() {
                const commonOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                };

                // Line chart for execution history
                const ctx1 = document.getElementById('executionHistoryChart');
                if (ctx1) {
                    this.executionHistory = new Chart(ctx1, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: []
                        },
                        options: {
                            ...commonOptions,
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        unit: 'day',
                                        displayFormats: {
                                            day: 'MMM d'
                                        }
                                    },
                                    title: {
                                        display: true,
                                        text: 'Date'
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Count'
                                    }
                                }
                            }
                        }
                    });
                }

                // Bar chart for task distribution
                const ctx2 = document.getElementById('taskDistributionChart');
                if (ctx2) {
                    this.taskDistribution = new Chart(ctx2, {
                        type: 'bar',
                        data: {
                            labels: [],
                            datasets: []
                        },
                        options: {
                            ...commonOptions,
                            scales: {
                                x: {
                                    stacked: true
                                },
                                y: {
                                    stacked: true,
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Count'
                                    }
                                }
                            }
                        }
                    });
                }

                // Initial update
                this.updateCharts();
            },

            updateCharts() {
                const now = Date.now();
                // Throttle updates to prevent excessive redraws
                if (this.lastUpdateTime && now - this.lastUpdateTime < 1000) {
                    return;
                }
                this.lastUpdateTime = now;

                const history = Alpine.store('data').analytics?.executionHistory || [];
                const distribution = Alpine.store('data').analytics?.taskDistribution || [];

                // Update execution history chart
                if (this.executionHistory && history.length > 0) {
                    this.hasExecutionData = true;
                    const historyData = {
                        labels: history.map(d => new Date(d.date)),
                        datasets: [
                            {
                                label: 'Completed',
                                data: history.map(d => ({
                                    x: new Date(d.date),
                                    y: d.completed
                                })),
                                borderColor: '#10b981',
                                backgroundColor: '#10b981',
                                fill: false,
                                tension: 0.1
                            },
                            {
                                label: 'Failed',
                                data: history.map(d => ({
                                    x: new Date(d.date),
                                    y: d.failed
                                })),
                                borderColor: '#ef4444',
                                backgroundColor: '#ef4444',
                                fill: false,
                                tension: 0.1
                            }
                        ]
                    };
                    this.executionHistory.data = historyData;
                    this.executionHistory.update('none');
                }

                // Update task distribution chart
                if (this.taskDistribution && distribution.length > 0) {
                    this.hasDistributionData = true;
                    const distributionData = {
                        labels: distribution.map(d => d.task),
                        datasets: [
                            {
                                label: 'Completed',
                                data: distribution.map(d => d.completed),
                                backgroundColor: '#10b981'
                            },
                            {
                                label: 'Failed',
                                data: distribution.map(d => d.failed),
                                backgroundColor: '#ef4444'
                            }
                        ]
                    };
                    this.taskDistribution.data = distributionData;
                    this.taskDistribution.update('none');
                }
            },

            // Rest of your utility functions remain the same
            getStatusEmoji(status) {
                return {
                    'COMPLETED': '✅',
                    'FAILED': '❌',
                    'RUNNING': '⏳',
                    'PENDING': '⏰'
                }[status] || '❔';
            },

            formatTimeAgo(date) {
                const seconds = Math.floor((new Date() - new Date(date)) / 1000);
                const intervals = {
                    year: 31536000,
                    month: 2592000,
                    week: 604800,
                    day: 86400,
                    hour: 3600,
                    minute: 60
                };

                for (const [unit, secondsInUnit] of Object.entries(intervals)) {
                    const interval = Math.floor(seconds / secondsInUnit);
                    if (interval >= 1) {
                        return `${interval} ${unit}${interval === 1 ? '' : 's'} ago`;
                    }
                }
                return 'just now';
            },

            formatDuration(seconds) {
                return `${seconds.toFixed(1)}s`;
            },

            formatDate(date) {
                return new Date(date).toLocaleString();
            }
        };
    }
</script>
{% endblock %}
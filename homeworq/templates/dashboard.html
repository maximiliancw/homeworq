{% extends "base.html" %}
{% block title %}Dashboard{% endblock %}

{% block content %}
<section x-data="dashboard()" class="container">
    <!-- Summary Metrics -->
    <div class="grid">
        <article>
            <header>
                <h3>Total Tasks</h3>
                <p x-text="metrics.totalTasks || '-'"></p>
            </header>
            <small>Last updated <span x-text="timeAgo(metrics.lastUpdate)"></span></small>
        </article>
        <article>
            <header>
                <h3>Active Tasks</h3>
                <p x-text="metrics.activeTasks || '-'"></p>
            </header>
            <small>Last updated <span x-text="timeAgo(metrics.lastUpdate)"></span></small>
        </article>
        <article>
            <header>
                <h3>Scheduled Jobs</h3>
                <p x-text="metrics.scheduledTasks || '-'"></p>
            </header>
            <small>Last updated <span x-text="timeAgo(metrics.lastUpdate)"></span></small>
        </article>
        <article>
            <header>
                <h3>System Status</h3>
                <p>
                    <kbd x-bind:class="health.status === 'healthy' ? 'success' : 'error'"
                        x-text="health.status">healthy</kbd>
                </p>
            </header>
            <small>Last updated <span x-text="timeAgo(metrics.lastUpdate)"></span></small>
        </article>
    </div>

    <!-- Recent Activity & Next Executions -->
    <div class="grid">
        <article>
            <header>
                <h3>Recent Activity</h3>
            </header>
            <div class="activity-feed">
                <template x-if="recentActivity.length === 0">
                    <p class="text-muted">No recent activity</p>
                </template>
                <template x-for="exec in recentActivity" :key="exec.started_at">
                    <div class="activity-item">
                        <span x-text="getStatusEmoji(exec.status)"></span>
                        <span><strong x-text="exec.job.task.name"></strong></span>
                        <span x-text="timeAgo(exec.started_at)"></span>
                        <span x-show="exec.duration" x-text="formatDuration(exec.duration)"></span>
                    </div>
                </template>
            </div>
        </article>
        <article>
            <header>
                <h3>Upcoming Executions</h3>
            </header>
            <div class="upcoming-list">
                <template x-if="upcomingExecutions.length === 0">
                    <p class="text-muted">No upcoming executions</p>
                </template>
                <template x-for="job in upcomingExecutions" :key="job.next_run">
                    <div class="upcoming-item">
                        <span><strong x-text="job.name"></strong></span>
                        <span x-text="formatNextRun(job.next_run)"></span>
                    </div>
                </template>
            </div>
        </article>
    </div>

    <!-- Charts -->
    <div class="grid">
        <article>
            <header>
                <h3>Execution History</h3>
            </header>
            <div class="chart-container">
                <canvas id="executionHistoryChart"></canvas>
                <template x-if="!hasExecutionData">
                    <p class="text-muted text-center">No execution data available</p>
                </template>
            </div>
        </article>
        <article>
            <header>
                <h3>Task Distribution</h3>
            </header>
            <div class="chart-container">
                <canvas id="taskDistributionChart"></canvas>
                <template x-if="!hasDistributionData">
                    <p class="text-muted text-center">No distribution data available</p>
                </template>
            </div>
        </article>
    </div>
</section>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    function dashboard() {
        return {
            metrics: {
                totalTasks: 0,
                activeTasks: 0,
                scheduledTasks: 0,
                lastUpdate: new Date()
            },
            health: {
                status: 'unknown'
            },
            recentActivity: [],
            upcomingExecutions: [],
            charts: {
                executionHistory: null,
                taskDistribution: null
            },
            hasExecutionData: false,
            hasDistributionData: false,

            timeAgo(date) {
                if (!date) return 'never';

                try {
                    const now = new Date();
                    const parsedDate = new Date(date);

                    // Check for invalid dates
                    if (isNaN(parsedDate.getTime())) {
                        return 'invalid date';
                    }

                    // Handle future dates
                    if (parsedDate > now) {
                        return 'in the future';
                    }

                    const seconds = Math.floor((now - parsedDate) / 1000);

                    // Define time intervals in seconds
                    const intervals = {
                        year: 31536000,
                        month: 2592000,
                        week: 604800,
                        day: 86400,
                        hour: 3600,
                        minute: 60,
                        second: 1
                    };

                    // Find the most appropriate time unit
                    for (const [unit, secondsInUnit] of Object.entries(intervals)) {
                        const interval = Math.floor(seconds / secondsInUnit);
                        if (interval >= 1) {
                            // Special handling for months/years to be more accurate
                            if (unit === 'year' || unit === 'month') {
                                const date1 = new Date(parsedDate);
                                const date2 = new Date(now);
                                if (unit === 'year') {
                                    const years = date2.getFullYear() - date1.getFullYear();
                                    if (years >= 1) {
                                        return `${years} year${years === 1 ? '' : 's'} ago`;
                                    }
                                } else {
                                    const months = (date2.getFullYear() - date1.getFullYear()) * 12 +
                                        (date2.getMonth() - date1.getMonth());
                                    if (months >= 1) {
                                        return `${months} month${months === 1 ? '' : 's'} ago`;
                                    }
                                }
                            } else {
                                return `${interval} ${unit}${interval === 1 ? '' : 's'} ago`;
                            }
                        }
                    }

                    // Less than a second ago
                    return 'just now';
                } catch (error) {
                    console.error('Error in timeAgo:', error);
                    return 'unknown';
                }
            },

            async fetchExecutions() {
                try {
                    const jobs = await fetch('/api/jobs').then(r => r.json());
                    const executions = await Promise.all(
                        jobs.map(job =>
                            fetch(`/api/jobs/${job.uid}/history?limit=10`)
                                .then(r => r.json())
                                .catch(e => {
                                    console.error(`Error fetching history for job ${job.uid}:`, e);
                                    return [];
                                })
                        )
                    );
                    return executions.flat().sort((a, b) =>
                        new Date(b.started_at) - new Date(a.started_at)
                    );
                } catch (e) {
                    console.error('Error fetching executions:', e);
                    return [];
                }
            },

            getStatusEmoji(status) {
                const emojis = {
                    'COMPLETED': '✅',
                    'FAILED': '❌',
                    'RUNNING': '⏳',
                    'PENDING': '⏰'
                };
                return emojis[status] || '❔';
            },

            formatDuration(seconds) {
                if (!seconds) return '';
                if (seconds < 60) return `${seconds.toFixed(1)}s`;
                const minutes = Math.floor(seconds / 60);
                seconds = Math.round(seconds % 60);
                return `${minutes}m ${seconds}s`;
            },

            formatNextRun(date) {
                if (!date) return 'Not scheduled';
                return new Date(date).toLocaleString();
            },

            async updateMetrics(health, tasks, jobs) {
                this.health = health;
                this.metrics = {
                    totalTasks: Object.keys(tasks).length,
                    activeTasks: jobs.filter(j => j.enabled).length,
                    scheduledTasks: jobs.length,
                    lastUpdate: new Date()
                };
            },

            updateActivityFeed(executions) {
                this.recentActivity = executions.slice(0, 10);
            },

            updateUpcomingExecutions(jobs) {
                this.upcomingExecutions = jobs
                    .filter(job => job.enabled && job.next_run)
                    .map(job => ({
                        name: job.task.name,
                        next_run: job.next_run
                    }))
                    .sort((a, b) => new Date(a.next_run) - new Date(b.next_run))
                    .slice(0, 5);
            },

            updateCharts(executions) {
                if (executions.length === 0) {
                    this.hasExecutionData = false;
                    this.hasDistributionData = false;
                    return;
                }
                this.updateExecutionHistoryChart(executions);
                this.updateTaskDistributionChart(executions);
            },

            updateExecutionHistoryChart(executions) {
                const ctx = document.getElementById('executionHistoryChart');
                if (!ctx) return;

                if (this.charts.executionHistory) {
                    this.charts.executionHistory.destroy();
                }

                // Group executions by day and status
                const grouped = executions.reduce((acc, exec) => {
                    const date = new Date(exec.started_at).toLocaleDateString();
                    if (!acc[date]) acc[date] = { COMPLETED: 0, FAILED: 0 };
                    if (exec.status === 'COMPLETED' || exec.status === 'FAILED') {
                        acc[date][exec.status]++;
                    }
                    return acc;
                }, {});

                const labels = Object.keys(grouped);
                this.hasExecutionData = labels.length > 0;

                if (!this.hasExecutionData) return;

                this.charts.executionHistory = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Successful',
                            data: Object.values(grouped).map(d => d.COMPLETED),
                            backgroundColor: '#2ecc71'
                        }, {
                            label: 'Failed',
                            data: Object.values(grouped).map(d => d.FAILED),
                            backgroundColor: '#e74c3c'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                stacked: true
                            },
                            x: {
                                stacked: true
                            }
                        }
                    }
                });
            },

            updateTaskDistributionChart(executions) {
                const ctx = document.getElementById('taskDistributionChart');
                if (!ctx) return;

                if (this.charts.taskDistribution) {
                    this.charts.taskDistribution.destroy();
                }

                // Group completed executions by task
                const grouped = executions
                    .filter(exec => exec.status === 'COMPLETED')
                    .reduce((acc, exec) => {
                        const task = exec.job.task.name;
                        acc[task] = (acc[task] || 0) + 1;
                        return acc;
                    }, {});

                const labels = Object.keys(grouped);
                this.hasDistributionData = labels.length > 0;

                if (!this.hasDistributionData) return;

                this.charts.taskDistribution = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: Object.values(grouped),
                            backgroundColor: [
                                '#2ecc71', '#3498db', '#9b59b6', '#f1c40f', '#e74c3c'
                            ]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false
                    }
                });
            },

            async init() {
                await this.fetchDashboardData();
                setInterval(() => this.fetchDashboardData(), 30000);
            },

            async fetchDashboardData() {
                try {
                    const [health, tasks, jobs, executions] = await Promise.all([
                        fetch('/api/health').then(r => r.json()),
                        fetch('/api/tasks').then(r => r.json()),
                        fetch('/api/jobs').then(r => r.json()),
                        this.fetchExecutions()
                    ]);

                    this.updateMetrics(health, tasks, jobs);
                    this.updateActivityFeed(executions);
                    this.updateUpcomingExecutions(jobs);
                    this.updateCharts(executions);

                } catch (error) {
                    console.error('Error fetching dashboard data:', error);
                    showToast('Error updating dashboard', 'error');
                }
            }
        }
    }
</script>
{% endblock %}